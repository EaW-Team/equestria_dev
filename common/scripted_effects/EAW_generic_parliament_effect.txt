# This file define a set of effects used to generate parliament SGUI

# There can be only one parliament per scope
# The parliament have a number M of seats, a seat represent one deputy
# A party is a set of deputies represented with the same color
# A parliament have N party, N being a positive integer that is not 0
# The party are represented with positive integer, from 0 the most left to N-1 the most right


# Variables lists
# - generic_parliament_seat_a  : Array with the state of each seat
# - generic_parliament_party_a : Array with the number of deputies allocated to each party
# - generic_parliament_random_balance_a : Array containing a list of randomly sorted party index

## Functions ##

# Function    : f_eaw_parliament_activate_verbose
# Description : Activate multiple sanity checks and debug verbose for the parliament interface
# Inputs      : None
# Outputs     : None
f_eaw_parliament_activate_verbose = {
	set_variable = { generic_parliament_debug_verbose = 1 }
}

# Function    : f_eaw_parliament_deactivate_verbose
# Description : Deactivate multiple sanity checks and debug verbose for the parliament interface
# Inputs      : None
# Outputs     : None
f_eaw_parliament_deactivate_verbose = {
	set_variable = { generic_parliament_debug_verbose = 0 }
}

# Function    : f_eaw_parliament_set_parliament_state
# Description : Allocate the seats of the parliament to the different parties
#               Override the number of party and deputy allocation previously held in the parliament
# Inputs      : i_parties_a - Array representing the parties
# Outputs     : None
f_eaw_parliament_set_parliament_state = {
	clear_array = generic_parliament_seat_a
	clear_array = generic_parliament_party_a

	# Sanity checks: number of seat and if it is integers
	if = {
		limit = { check_variable = { generic_parliament_debug_verbose > 0 } }

		set_temp_variable = { t_accumulator = 0 }
		for_each_loop = {
			array = i_parties_a
			index = party_index
			value = party_value

			add_to_temp_variable = { t_accumulator = party_value }
			set_temp_variable = { t_val = party_value }
			round_temp_variable = t_val
			if = {
				limit = { NOT = {check_variable = { t_val = party_value }} }
				log = "f_eaw_parliament_set_parliament_state : [THIS.GetName] - Number of seat for the party [?party_index] is not an integer"
			}
		}
		if = {
			limit = { check_variable = { t_accumulator = i_parties_a } }
			log = "f_eaw_parliament_set_parliament_state : [THIS.GetName] - Incorrect number of seat in i_parties_a"
		}
	}

	for_each_loop = {
		array = i_parties_a
		index = party_index
		value = party_value

		for_loop_effect = {
			end = party_value
			value = deputy_index

			add_to_array = { generic_parliament_seat_a = party_index }
		}
		add_to_array = { generic_parliament_party_a = party_value }
	}

	f_eaw_parliament_refresh_random_party_list = yes
}

# Function    : f_eaw_parliament_add_party
# Description : Dynamicaly add a new party in the parliament
# Inputs      : i_party_index - Position of the party to add
# Outputs     : None
f_eaw_parliament_add_party = {
	# Sanity checks: verify the index is an integer in the range of the array
	if = {
		limit = { check_variable = { generic_parliament_debug_verbose > 0 } }

		# Integer checks
		set_temp_variable = { t_val = i_party_index }
		round_temp_variable = t_val
		if = {
			limit = { NOT = {check_variable = { t_val = i_party_index }} }
			log = "f_eaw_parliament_add_party : [THIS.GetName] - The index of the new party i_party_index is not an integer (i_party_index = [?i_party_index])"
		}

		# Range checks
		if = {
			limit = {
				OR = {
					check_variable = { i_party_index < 0 }
					check_variable = { i_party_index > generic_parliament_party_a^num }
				}
			}
			log = "f_eaw_parliament_add_party : [THIS.GetName] - The index of the new party i_party_index is out of range of the actual party array size ([?generic_parliament_party_a^num])"
		}
	}

	# Adding the party to the array
	add_to_array = {
		array = generic_parliament_party_a
		index = i_party_index
		value = 0
	}

	f_eaw_parliament_refresh_random_party_list = yes
}

# Function    : f_eaw_parliament_switch_deputies
# Description : Deputies switch from one party to the other. The changes is given by an input array
# Inputs      : i_party_deputy_change_a - An array containing the changes in deputy.
#                   The number of entry is equal to the number of parties, and the sum of the elements have to be 0
#                   Exemple, with 4 parties : [0, -1, 3, -2]. 0 gains 0, 1 loses 1, 2 gains 3 and 3 loses 2
# Outputs     : i_party_deputy_change_a - The actual change done by the function. Modify the input array
f_eaw_parliament_switch_deputies = {
	# Sanity checks
	if = {
		limit = { check_variable = { generic_parliament_debug_verbose > 0 } }

		# Check that the input array has the correct number of party
		if = {
			limit = { NOT = {check_variable = { i_party_deputy_change_a^num = generic_parliament_party_a^num }} }
			log = "f_eaw_parliament_switch_deputies : [THIS.GetName] - The input array length ([?i_party_deputy_change_a^num]) is different from the number of party ([?generic_parliament_party_a^num]) in the parliament"
		}

		set_temp_variable = { t_deputy_change = 0 }
		for_each_loop = {
			array = i_party_deputy_change_a
			value = sw_deputy
			index = sw_party

			# Check that the number is an integer
			set_temp_variable = { t_old_change_value = sw_deputy }
			round_temp_variable = t_old_change_value
			if = {
				limit = { NOT = { check_variable = { t_old_change_value = sw_deputy } } }
				log = "f_eaw_parliament_switch_deputies : [THIS.GetName] - The value in the input array i_party_deputy_change_a([?sw_party]) = [?sw_deputy] is not an integer"
			}
			set_temp_variable = { i_party_deputy_change_a^sw_party = t_old_change_value }

			add_to_temp_variable = { t_deputy_change = sw_deputy }
		}

		# Check that the sum of the elements is zero
		if = {
			limit = {
				NOT = { check_variable = { t_deputy_change = 0 } }
			}

			log = "f_eaw_parliament_switch_deputies : [THIS.GetName] - The sum of the elements of the input array i_party_deputy_change_a is not zero"
		}
	}

	# Get the defficit of deputy after taking into account the party that doesn't have enough to give
	set_temp_variable = { t_deputies_to_subtract = 0 }
	for_each_loop = {
		array = i_party_deputy_change_a
		index = party_index
		value = wished_deputy_change

		if = {
			limit = { check_variable = { wished_deputy_change < 0 } }

			if = {
				limit =  {
					set_temp_variable = { t_cmp = generic_parliament_party_a^party_index }
					multiply_temp_variable = { t_cmp = -1 }
					check_variable = { wished_deputy_change < t_cmp }
				}

				set_temp_variable = { i_party_deputy_change_a^party_index = generic_parliament_party_a^party_index }
				multiply_temp_variable = { i_party_deputy_change_a^party_index = -1 }
			}

			add_to_temp_variable = { t_deputies_to_subtract = i_party_deputy_change_a^party_index }

		} else = {
			add_to_temp_variable = { t_deputies_to_subtract = wished_deputy_change }
		}
	}

	# Compute the number of deputy to compensate in the add
	if = {
		limit = {
			check_variable = { t_deputies_to_subtract > 0 }
		}

		# Loop the positive until all the deputy to substract are compensated
		set_temp_variable = { t_random_party_index = 0 }
		for_loop_effect = {
			end = t_deputies_to_subtract
			value = update_seat_iterator

			while_loop_effect = {
				limit = {
					set_temp_variable = { t_random_party_index = generic_parliament_random_balance_a^t_random_iterator }
					check_variable = { i_party_deputy_change_a^t_random_party_index < 1 }
				}

				add_to_temp_variable = { t_random_iterator = 1 }
				modulo_temp_variable = { t_random_iterator = generic_parliament_random_balance_a^num }
			}

			add_to_temp_variable = { i_party_deputy_change_a^t_random_party_index = -1 }

			add_to_temp_variable = { t_random_iterator = 1 }
			modulo_temp_variable = { t_random_iterator = generic_parliament_random_balance_a^num }
		}

		# Refresh the random party array for compensation
		f_eaw_parliament_refresh_random_party_list = yes
	}

	# Apply the seat change
	f_eaw_parliament_change_seats_priv = yes

}

# Function    : f_eaw_parliament_balance_change_deputies
# Description : Add or substract a certain deputy amount to a party.
#               The number of deputies being taken / given is balanced between all the others parties.
#               For example, trying to give 4 deputies to a 3 parties parliament will results with a lose of 2 deputies for each of the other parties
# Inputs      : i_party     - The party ID that the change will be applied to.
#               i_deputy_nb - The change in deputies the change will be
# Outputs     : i_party_deputy_change_a - The actual array of changes done by the function.
f_eaw_parliament_balance_change_deputies = {
	# Sanity checks
	if = {
		limit = { check_variable = { generic_parliament_debug_verbose > 0 } }

		# Integer checks
		set_temp_variable = { t_val = i_party }
		round_temp_variable = t_val
		if = {
			limit = { NOT = {check_variable = { t_val = i_party }} }
			log = "f_eaw_parliament_balance_change_deputies : [THIS.GetName] - The index of the party i_party is not an integer (i_party = [?i_party])"
		}
		set_temp_variable = { t_val = i_deputy_nb }
		round_temp_variable = t_val
		if = {
			limit = { NOT = {check_variable = { t_val = i_deputy_nb }} }
			log = "f_eaw_parliament_balance_change_deputies : [THIS.GetName] - The number of change for the deputies i_deputy_nb is not an integer (i_deputy_nb = [?i_deputy_nb])"
		}

		# Range check
		if = {
			limit = {
				OR = {
					check_variable = { i_party < 0 }
					check_variable = {
						var = i_party
						value = generic_parliament_party_a^num
						compare = greater_than_or_equals
					}
				}
			}

			log = "f_eaw_parliament_balance_change_deputies : [THIS.GetName] - The party index i_party is out of range (i_party = [?i_party])"
		}
	}

	# Compute effective deputy change
	set_temp_variable = { t_effective_deputy_change = i_deputy_nb }
	add_to_temp_variable = { t_effective_deputy_change = generic_parliament_party_a^i_party }
	clamp_temp_variable = {
		var = t_effective_deputy_change
		min = 0
		max = generic_parliament_seat_a^num
	}
	subtract_from_temp_variable = { t_effective_deputy_change = generic_parliament_party_a^i_party }
	log = "Effective deputy change [?t_effective_deputy_change]"

	# Number of other parties
	set_temp_variable = { t_nb_other_parties = generic_parliament_party_a^num }
	add_to_temp_variable = { t_nb_other_parties = -1 }

	# Get integer part
	set_temp_variable = { t_integer_change = t_effective_deputy_change }
	divide_temp_variable = { t_integer_change = t_nb_other_parties }
	add_to_temp_variable = { t_integer_change = -0.499 }
	round_temp_variable = t_integer_change
	multiply_temp_variable = { t_integer_change = -1 }
	log = "Integer change for each party [?t_integer_change]"

	# Apply integer changes
	set_temp_variable = { t_remaining_deputies = t_effective_deputy_change }
	for_loop_effect = {
		end = generic_parliament_party_a^num
		value = party_index

		if = {
			limit = { NOT = {check_variable = { party_index = i_party }} }

			set_temp_variable = { t_deputy_change = t_integer_change }
			add_to_temp_variable = { t_deputy_change = generic_parliament_party_a^party_index }
			clamp_temp_variable = {
				var = t_deputy_change
				min = 0
				max = generic_parliament_seat_a^num
			}
			subtract_from_temp_variable = { t_deputy_change = generic_parliament_party_a^party_index }
			add_to_temp_array = { i_party_deputy_change_a = t_deputy_change }
			add_to_temp_variable = { t_remaining_deputies = t_deputy_change }

		} else = {
			add_to_temp_array = { i_party_deputy_change_a = t_effective_deputy_change }
		}
	}

	# Get remaining deputy to switch
	multiply_temp_variable = { t_remaining_deputies = -1 }

	if = {
		limit = { NOT = { check_variable = { t_remaining_deputies = 0 }}}

		set_temp_variable = { t_incr = 1 }
		if = {
			limit = { check_variable = { t_remaining_deputies > 0 } }
			set_temp_variable = { t_incr = -1 }
		}

		log = "Remaing deputies [?t_remaining_deputies]"
		while_loop_effect = {
			limit = { NOT = {check_variable = { t_remaining_deputies = 0 }} }

			while_loop_effect = {
				limit = {
					set_temp_variable = { t_random_party_index = generic_parliament_random_balance_a^t_random_iterator }

					set_temp_variable = { t_deputy_number = generic_parliament_party_a^t_random_party_index }
					subtract_from_temp_variable = { t_deputy_number = t_incr }
					add_to_temp_variable = { t_deputy_number = i_party_deputy_change_a^t_random_party_index }
					OR = {
						check_variable = { t_random_party_index = i_party }
						check_variable = { t_deputy_number < 0 }
						check_variable = { t_deputy_number > generic_parliament_seat_a^num }
					}
				}

				add_to_temp_variable = { t_random_iterator = 1 }
				modulo_temp_variable = { t_random_iterator = generic_parliament_random_balance_a^num }
			}

			log = "Choosen index [?t_random_party_index]"

			subtract_from_temp_variable = { i_party_deputy_change_a^t_random_party_index = t_incr }
			add_to_temp_variable = { t_remaining_deputies = t_incr }

			add_to_temp_variable = { t_random_iterator = 1 }
			modulo_temp_variable = { t_random_iterator = generic_parliament_random_balance_a^num }
		}

		# Refresh the random party array for compensation
		f_eaw_parliament_refresh_random_party_list = yes
	}

	# Apply the seat change
	f_eaw_parliament_change_seats_priv = yes
}

# Function    : f_eaw_parliament_update_seats
# Description : Refresh the seats array for the display
# Inputs      : None
# Outputs     : None
f_eaw_parliament_update_seats = {
	clear_array = generic_parliament_seat_a
	for_each_loop = {
		array = generic_parliament_party_a
		index = party_index
		value = party_value

		for_loop_effect = {
			end = party_value
			value = deputy_index

			add_to_array = { generic_parliament_seat_a = party_index }
		}
	}
}

# Function    : f_eaw_parliament_get_sorted_parliament
# Description : Return an array with the index of the parties sorted in an ascending manner
# Inputs      : None
# Outputs     : o_sorted_party_a - Sorted list of party, from index 0 the party with the less deputies, to the party with the most
f_eaw_parliament_get_sorted_parliament = {
	resize_temp_array = { o_sorted_party_a = 0 }
	resize_temp_array = { t_party_deputy_a = 0 }
	for_each_loop = {
		array = generic_parliament_party_a
		add_to_temp_array = { o_sorted_party_a = i }
		add_to_temp_array = { t_party_deputy_a = v }
	}

	# An insertion sort because I cannot be bothered
	for_loop_effect = {
		start = 1
		end = t_party_deputy_a^num
		value = sorting_index

		set_temp_variable = { curr_index = sorting_index }
		while_loop_effect = {
			limit = {
				check_variable = { curr_index > 0 }
				set_temp_variable = { curr_index_1 = curr_index }
				add_to_temp_variable = { curr_index_1 = -1 }
				check_variable = { t_party_deputy_a^curr_index_1 > t_party_deputy_a^curr_index }
			}

			# Swap the values
			set_temp_variable = { t_value = t_party_deputy_a^curr_index_1 }
			set_temp_variable = { t_party_deputy_a^curr_index_1 = t_party_deputy_a^curr_index }
			set_temp_variable = { t_party_deputy_a^curr_index   = t_value }

			set_temp_variable = { t_value = o_sorted_party_a^curr_index_1 }
			set_temp_variable = { o_sorted_party_a^curr_index_1 = o_sorted_party_a^curr_index }
			set_temp_variable = { o_sorted_party_a^curr_index   = t_value}

			add_to_temp_variable = { curr_index = -1 }
		}
	}
}

# Function    : f_eaw_parliament_get_majority_party
# Description : Return the ID of the party with the majority
#               In case of a ties for the majority, another variable is output with the number of tied parties
# Inputs      : None
# Outputs     : o_winner - The ID of the winning party (With the most seats
#               o_ties   - 0 if no ties, otherwise the number of parties with the same number of deputies that have "won"
f_eaw_parliament_get_majority_party = {
	set_temp_variable = { o_winner = 0 }
	set_temp_variable = { o_ties   = 0 }

	set_temp_variable = { t_deputy_nb = generic_parliament_party_a^0 }
	for_loop_effect = {
		start = 1
		end = generic_parliament_party_a^num
		value = party_index

		set_temp_variable = { t_curr_deputy_nb = generic_parliament_party_a^party_index }
		if = {
			limit = { check_variable = {t_curr_deputy_nb > t_deputy_nb} }

			set_temp_variable = { t_deputy_nb = t_curr_deputy_nb }
			set_temp_variable = { o_winner    = party_index }
			set_temp_variable = { o_ties      = 0 }

		} else_if = {
			limit = { check_variable = {t_curr_deputy_nb = t_deputy_nb}  }

			add_to_temp_variable = { o_ties = 1 }
		}
	}
}

### Private Functions ###

# Function    : f_eaw_parliament_change_seats_priv
# Description : Private function - Change without rebalancing or checks the number of deputies for each
# Inputs      : i_party_deputy_change_a - The changes to apply to the party array
# Outputs     : None
f_eaw_parliament_change_seats_priv = {
	for_each_loop = {
		array = i_party_deputy_change_a
		index = party_modif_index
		value = party_modif_value

		log = "Party [?party_modif_index]: [?party_modif_value]"
		add_to_variable = { generic_parliament_party_a^party_modif_index = party_modif_value }
	}
}

# Function    : f_eaw_parliament_refresh_random_party_list
# Description : Private function - Refresh the list used to randomly balance the deputy for the computation
# Inputs      : None
# Outputs     : None
f_eaw_parliament_refresh_random_party_list = {
	if = {
		limit = { NOT = {check_variable = { generic_parliament_random_balance_a^num = generic_parliament_party_a^num }} }

		clear_array = generic_parliament_random_balance_a
		for_loop_effect = {
			end = generic_parliament_party_a^num
			value = iterator

			add_to_array = { generic_parliament_random_balance_a = iterator }
		}
	}

	set_temp_variable = { t_max = generic_parliament_party_a^num }
	add_to_temp_variable = { t_max = -1 }
	for_loop_effect = {
		end = t_max
		value = iterator

		set_temp_variable_to_random = {
			var = t_random_index
			min = iterator
			max = generic_parliament_party_a^num
			integer = yes
		}
		set_temp_variable = { t_val = generic_parliament_random_balance_a^iterator }
		set_variable = { generic_parliament_random_balance_a^iterator = generic_parliament_random_balance_a^t_random_index }
		set_variable = { generic_parliament_random_balance_a^t_random_index = t_val }
	}
}
